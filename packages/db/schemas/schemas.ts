/*
 * ==========================================
 * |          GENERATED BY SUPAZOD          |
 * ==========================================
 */

import { z } from "zod";
import type { Json } from "./../types/types";

export const jsonSchema: z.ZodSchema<Json> = z.lazy(() =>
  z
    .union([z.string(), z.number(), z.boolean(), z.record(z.union([jsonSchema, z.undefined()])), z.array(jsonSchema)])
    .nullable(),
);

export const publicGenresRowSchemaSchema = z.object({
  created_at: z.string(),
  genre_id: z.number(),
  id: z.number(),
  name: z.string(),
});

export const publicGenresInsertSchemaSchema = z.object({
  created_at: z.string().optional(),
  genre_id: z.number(),
  id: z.number().optional(),
  name: z.string(),
});

export const publicGenresUpdateSchemaSchema = z.object({
  created_at: z.string().optional(),
  genre_id: z.number().optional(),
  id: z.number().optional(),
  name: z.string().optional(),
});

export const publicReleasegroupsRowSchemaSchema = z.object({
  created_at: z.string(),
  id: z.number(),
  is_supported: z.boolean().nullable(),
  matches: z.array(z.string()),
  release_group_name: z.string(),
});

export const publicReleasegroupsInsertSchemaSchema = z.object({
  created_at: z.string().optional(),
  id: z.number().optional(),
  is_supported: z.boolean().optional().nullable(),
  matches: z.array(z.string()),
  release_group_name: z.string(),
});

export const publicReleasegroupsUpdateSchemaSchema = z.object({
  created_at: z.string().optional(),
  id: z.number().optional(),
  is_supported: z.boolean().optional().nullable(),
  matches: z.array(z.string()).optional(),
  release_group_name: z.string().optional(),
});

export const publicSubtitlegroupsRowSchemaSchema = z.object({
  created_at: z.string(),
  id: z.number(),
  subtitle_group_name: z.string(),
  website: z.string(),
});

export const publicSubtitlegroupsInsertSchemaSchema = z.object({
  created_at: z.string().optional(),
  id: z.number().optional(),
  subtitle_group_name: z.string(),
  website: z.string(),
});

export const publicSubtitlegroupsUpdateSchemaSchema = z.object({
  created_at: z.string().optional(),
  id: z.number().optional(),
  subtitle_group_name: z.string().optional(),
  website: z.string().optional(),
});

export const publicSubtitlesRowSchemaSchema = z.object({
  author: z.string().nullable(),
  bytes: z.number(),
  created_at: z.string(),
  current_episode: z.number().nullable(),
  current_season: z.number().nullable(),
  external_id: z.string(),
  file_extension: z.string(),
  id: z.number(),
  is_valid: z.boolean(),
  lang: z.string(),
  last_queried_at: z.string().nullable(),
  queried_times: z.number().nullable(),
  release_group_id: z.number(),
  resolution: z.string(),
  reviewed: z.boolean(),
  rip_type: z.string().nullable(),
  subtitle_file_name: z.string(),
  subtitle_group_id: z.number(),
  subtitle_link: z.string(),
  time_to_index_in_s: z.number().nullable(),
  title_file_name: z.string(),
  title_slug: z.string(),
  torrent_id: z.number(),
  uploaded_by: z.string().nullable(),
});

export const publicSubtitlesInsertSchemaSchema = z.object({
  author: z.string().optional().nullable(),
  bytes: z.number(),
  created_at: z.string().optional(),
  current_episode: z.number().optional().nullable(),
  current_season: z.number().optional().nullable(),
  external_id: z.string(),
  file_extension: z.string(),
  id: z.number().optional(),
  is_valid: z.boolean(),
  lang: z.string(),
  last_queried_at: z.string().optional().nullable(),
  queried_times: z.number().optional().nullable(),
  release_group_id: z.number(),
  resolution: z.string(),
  reviewed: z.boolean(),
  rip_type: z.string().optional().nullable(),
  subtitle_file_name: z.string(),
  subtitle_group_id: z.number(),
  subtitle_link: z.string(),
  time_to_index_in_s: z.number().optional().nullable(),
  title_file_name: z.string(),
  title_slug: z.string(),
  torrent_id: z.number(),
  uploaded_by: z.string().optional().nullable(),
});

export const publicSubtitlesUpdateSchemaSchema = z.object({
  author: z.string().optional().nullable(),
  bytes: z.number().optional(),
  created_at: z.string().optional(),
  current_episode: z.number().optional().nullable(),
  current_season: z.number().optional().nullable(),
  external_id: z.string().optional(),
  file_extension: z.string().optional(),
  id: z.number().optional(),
  is_valid: z.boolean().optional(),
  lang: z.string().optional(),
  last_queried_at: z.string().optional().nullable(),
  queried_times: z.number().optional().nullable(),
  release_group_id: z.number().optional(),
  resolution: z.string().optional(),
  reviewed: z.boolean().optional(),
  rip_type: z.string().optional().nullable(),
  subtitle_file_name: z.string().optional(),
  subtitle_group_id: z.number().optional(),
  subtitle_link: z.string().optional(),
  time_to_index_in_s: z.number().optional().nullable(),
  title_file_name: z.string().optional(),
  title_slug: z.string().optional(),
  torrent_id: z.number().optional(),
  uploaded_by: z.string().optional().nullable(),
});

export const publicSubtitlesRelationshipsSchemaSchema = z.tuple([
  z.object({
    foreignKeyName: z.literal("Subtitles_release_group_id_fkey"),
    columns: z.tuple([z.literal("release_group_id")]),
    isOneToOne: z.literal(false),
    referencedRelation: z.literal("ReleaseGroups"),
    referencedColumns: z.tuple([z.literal("id")]),
  }),
  z.object({
    foreignKeyName: z.literal("Subtitles_subtitle_group_id_fkey"),
    columns: z.tuple([z.literal("subtitle_group_id")]),
    isOneToOne: z.literal(false),
    referencedRelation: z.literal("SubtitleGroups"),
    referencedColumns: z.tuple([z.literal("id")]),
  }),
  z.object({
    foreignKeyName: z.literal("Subtitles_title_slug_fkey"),
    columns: z.tuple([z.literal("title_slug")]),
    isOneToOne: z.literal(false),
    referencedRelation: z.literal("RandomTitles"),
    referencedColumns: z.tuple([z.literal("slug")]),
  }),
  z.object({
    foreignKeyName: z.literal("Subtitles_title_slug_fkey"),
    columns: z.tuple([z.literal("title_slug")]),
    isOneToOne: z.literal(false),
    referencedRelation: z.literal("Titles"),
    referencedColumns: z.tuple([z.literal("slug")]),
  }),
  z.object({
    foreignKeyName: z.literal("Subtitles_torrent_id_fkey"),
    columns: z.tuple([z.literal("torrent_id")]),
    isOneToOne: z.literal(false),
    referencedRelation: z.literal("Torrents"),
    referencedColumns: z.tuple([z.literal("id")]),
  }),
]);

export const publicSubtitlesnotfoundRowSchemaSchema = z.object({
  bytes: z.number(),
  created_at: z.string(),
  email: z.string().nullable(),
  id: z.number(),
  run_times: z.number(),
  title_file_name: z.string(),
});

export const publicSubtitlesnotfoundInsertSchemaSchema = z.object({
  bytes: z.number(),
  created_at: z.string().optional(),
  email: z.string().optional().nullable(),
  id: z.number().optional(),
  run_times: z.number().optional(),
  title_file_name: z.string(),
});

export const publicSubtitlesnotfoundUpdateSchemaSchema = z.object({
  bytes: z.number().optional(),
  created_at: z.string().optional(),
  email: z.string().optional().nullable(),
  id: z.number().optional(),
  run_times: z.number().optional(),
  title_file_name: z.string().optional(),
});

export const publicTitlegenresRowSchemaSchema = z.object({
  created_at: z.string(),
  genre_id: z.number(),
  id: z.number(),
  title_id: z.number(),
});

export const publicTitlegenresInsertSchemaSchema = z.object({
  created_at: z.string().optional(),
  genre_id: z.number(),
  id: z.number().optional(),
  title_id: z.number(),
});

export const publicTitlegenresUpdateSchemaSchema = z.object({
  created_at: z.string().optional(),
  genre_id: z.number().optional(),
  id: z.number().optional(),
  title_id: z.number().optional(),
});

export const publicTitlegenresRelationshipsSchemaSchema = z.tuple([
  z.object({
    foreignKeyName: z.literal("TitleGenres_genre_id_fkey"),
    columns: z.tuple([z.literal("genre_id")]),
    isOneToOne: z.literal(false),
    referencedRelation: z.literal("Genres"),
    referencedColumns: z.tuple([z.literal("genre_id")]),
  }),
  z.object({
    foreignKeyName: z.literal("TitleGenres_title_id_fkey"),
    columns: z.tuple([z.literal("title_id")]),
    isOneToOne: z.literal(false),
    referencedRelation: z.literal("Titles"),
    referencedColumns: z.tuple([z.literal("id")]),
  }),
]);

export const publicTitlesRowSchemaSchema = z.object({
  backdrop: z.string().nullable(),
  backdrop_thumbhash: z.string().nullable(),
  certification: z.string().nullable(),
  created_at: z.string(),
  id: z.number(),
  imdb_id: z.string(),
  justwatch_id: z.string().nullable(),
  last_queried_at: z.string().nullable(),
  letterboxd_id: z.string().nullable(),
  logo: z.string().nullable(),
  optimized_backdrop: z.string().nullable(),
  optimized_logo: z.string().nullable(),
  optimized_poster: z.string().nullable(),
  overview: z.string(),
  poster: z.string().nullable(),
  poster_thumbhash: z.string().nullable(),
  queried_times: z.number().nullable(),
  rating: z.number(),
  release_date: z.string(),
  rottentomatoes_id: z.string().nullable(),
  runtime: z.number().nullable(),
  searched_times: z.number().nullable(),
  slug: z.string(),
  spotify_id: z.string().nullable(),
  title_name: z.string(),
  title_name_ja: z.string().nullable(),
  title_name_spa: z.string(),
  title_name_without_special_chars: z.string(),
  total_episodes: z.number().nullable(),
  total_seasons: z.number().nullable(),
  type: z.string(),
  year: z.number(),
  youtube_id: z.string().nullable(),
});

export const publicTitlesInsertSchemaSchema = z.object({
  backdrop: z.string().optional().nullable(),
  backdrop_thumbhash: z.string().optional().nullable(),
  certification: z.string().optional().nullable(),
  created_at: z.string().optional(),
  id: z.number().optional(),
  imdb_id: z.string(),
  justwatch_id: z.string().optional().nullable(),
  last_queried_at: z.string().optional().nullable(),
  letterboxd_id: z.string().optional().nullable(),
  logo: z.string().optional().nullable(),
  optimized_backdrop: z.string().optional().nullable(),
  optimized_logo: z.string().optional().nullable(),
  optimized_poster: z.string().optional().nullable(),
  overview: z.string(),
  poster: z.string().optional().nullable(),
  poster_thumbhash: z.string().optional().nullable(),
  queried_times: z.number().optional().nullable(),
  rating: z.number(),
  release_date: z.string(),
  rottentomatoes_id: z.string().optional().nullable(),
  runtime: z.number().optional().nullable(),
  searched_times: z.number().optional().nullable(),
  slug: z.string(),
  spotify_id: z.string().optional().nullable(),
  title_name: z.string(),
  title_name_ja: z.string().optional().nullable(),
  title_name_spa: z.string(),
  title_name_without_special_chars: z.string(),
  total_episodes: z.number().optional().nullable(),
  total_seasons: z.number().optional().nullable(),
  type: z.string(),
  year: z.number(),
  youtube_id: z.string().optional().nullable(),
});

export const publicTitlesUpdateSchemaSchema = z.object({
  backdrop: z.string().optional().nullable(),
  backdrop_thumbhash: z.string().optional().nullable(),
  certification: z.string().optional().nullable(),
  created_at: z.string().optional(),
  id: z.number().optional(),
  imdb_id: z.string().optional(),
  justwatch_id: z.string().optional().nullable(),
  last_queried_at: z.string().optional().nullable(),
  letterboxd_id: z.string().optional().nullable(),
  logo: z.string().optional().nullable(),
  optimized_backdrop: z.string().optional().nullable(),
  optimized_logo: z.string().optional().nullable(),
  optimized_poster: z.string().optional().nullable(),
  overview: z.string().optional(),
  poster: z.string().optional().nullable(),
  poster_thumbhash: z.string().optional().nullable(),
  queried_times: z.number().optional().nullable(),
  rating: z.number().optional(),
  release_date: z.string().optional(),
  rottentomatoes_id: z.string().optional().nullable(),
  runtime: z.number().optional().nullable(),
  searched_times: z.number().optional().nullable(),
  slug: z.string().optional(),
  spotify_id: z.string().optional().nullable(),
  title_name: z.string().optional(),
  title_name_ja: z.string().optional().nullable(),
  title_name_spa: z.string().optional(),
  title_name_without_special_chars: z.string().optional(),
  total_episodes: z.number().optional().nullable(),
  total_seasons: z.number().optional().nullable(),
  type: z.string().optional(),
  year: z.number().optional(),
  youtube_id: z.string().optional().nullable(),
});

export const publicTorrentsRowSchemaSchema = z.object({
  created_at: z.string(),
  id: z.number(),
  torrent_bytes: z.number(),
  torrent_link: z.string(),
  torrent_name: z.string(),
  torrent_seeds: z.number(),
  torrent_size: z.string(),
  torrent_tracker: z.string(),
});

export const publicTorrentsInsertSchemaSchema = z.object({
  created_at: z.string().optional(),
  id: z.number().optional(),
  torrent_bytes: z.number(),
  torrent_link: z.string(),
  torrent_name: z.string(),
  torrent_seeds: z.number(),
  torrent_size: z.string(),
  torrent_tracker: z.string(),
});

export const publicTorrentsUpdateSchemaSchema = z.object({
  created_at: z.string().optional(),
  id: z.number().optional(),
  torrent_bytes: z.number().optional(),
  torrent_link: z.string().optional(),
  torrent_name: z.string().optional(),
  torrent_seeds: z.number().optional(),
  torrent_size: z.string().optional(),
  torrent_tracker: z.string().optional(),
});

export const publicRandomtitlesRowSchemaSchema = z.object({
  slug: z.string().nullable(),
});

export const publicRandomtitlesInsertSchemaSchema = z.object({
  slug: z.string().optional().nullable(),
});

export const publicRandomtitlesUpdateSchemaSchema = z.object({
  slug: z.string().optional().nullable(),
});

export const publicFuzzySearchTitleArgsSchemaSchema = z.object({
  query: z.string(),
});

export const publicFuzzySearchTitleReturnsSchemaSchema = z.array(
  z.object({
    id: z.number(),
    imdb_id: z.string(),
    title_name: z.string(),
    title_name_spa: z.string(),
    title_name_ja: z.string(),
    year: z.number(),
    type: z.string(),
    slug: z.string(),
    optimized_backdrop: z.string(),
    optimized_poster: z.string(),
    optimized_logo: z.string(),
    searched_times: z.number(),
    queried_times: z.number(),
    poster_thumbhash: z.string(),
    backdrop_thumbhash: z.string(),
    overview: z.string(),
    runtime: z.number(),
    rating: z.number(),
    youtube_id: z.string(),
  }),
);

export const publicGtrgmCompressArgsSchemaSchema = z.object({
  "": z.unknown(),
});

export const publicGtrgmCompressReturnsSchemaSchema = z.unknown();

export const publicGtrgmDecompressArgsSchemaSchema = z.object({
  "": z.unknown(),
});

export const publicGtrgmDecompressReturnsSchemaSchema = z.unknown();

export const publicGtrgmInArgsSchemaSchema = z.object({
  "": z.unknown(),
});

export const publicGtrgmInReturnsSchemaSchema = z.unknown();

export const publicGtrgmOptionsArgsSchemaSchema = z.object({
  "": z.unknown(),
});

export const publicGtrgmOptionsReturnsSchemaSchema = z.undefined();

export const publicGtrgmOutArgsSchemaSchema = z.object({
  "": z.unknown(),
});

export const publicGtrgmOutReturnsSchemaSchema = z.unknown();

export const publicSetLimitArgsSchemaSchema = z.object({
  "": z.number(),
});

export const publicSetLimitReturnsSchemaSchema = z.number();

export const publicShowLimitArgsSchemaSchema = z.object({});

export const publicShowLimitReturnsSchemaSchema = z.number();

export const publicShowTrgmArgsSchemaSchema = z.object({
  "": z.string(),
});

export const publicShowTrgmReturnsSchemaSchema = z.array(z.string());

export const publicSumQueriedTimesArgsSchemaSchema = z.object({});

export const publicSumQueriedTimesReturnsSchemaSchema = z.number();

export const publicUnaccentArgsSchemaSchema = z.object({
  "": z.string(),
});

export const publicUnaccentReturnsSchemaSchema = z.string();

export const publicUnaccentInitArgsSchemaSchema = z.object({
  "": z.unknown(),
});

export const publicUnaccentInitReturnsSchemaSchema = z.unknown();

export const publicUpdateSubtitleAndTitleDownloadMetricsArgsSchemaSchema = z.object({
  _title_slug: z.string(),
  _subtitle_id: z.number(),
});

export const publicUpdateSubtitleAndTitleDownloadMetricsReturnsSchemaSchema = z.boolean();

export const publicUpdateTitleSearchMetricsArgsSchemaSchema = z.object({
  _slug: z.string(),
});

export const publicUpdateTitleSearchMetricsReturnsSchemaSchema = z.boolean();
